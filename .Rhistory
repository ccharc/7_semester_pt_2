r_(k+1) <- A %*% x_(k+1) - b;
beta_(k+1) <- (t(r_(k+1)) %*% A %*% p_k)/ (t(p_k) %*% A %*% p_k);
p_(k+1) <- - r_(k+1) + beta_(k+1) * p_k
k <- k+1
}
return(x_k)
}
MinimizeCG51 <- function(x_k, A, b, k_max = 1000, tolerance = sqrt(.Machine$double.eps)) {
# Given x_0;
r_k <- Ax_k - b; p_k <- -r_k; k <- 0
while(r_k != 0 & k < k_max){
alpha_k <- - (t(r_k) * p_k)/(t(p_k) %*% A %*% p_k);
x_k <- x_k + alpha_k * p_k;
r_k <- A %*% x_k - b;
beta_k <- (t(r_k) %*% A %*% p_k)/ (t(p_k) %*% A %*% p_k);
p_k <- - r_k + beta_k * p_k
k <- k+1
}
return(x_k)
}
knitr::opts_chunk$set(echo = TRUE)
library(SoDA)
N <- 500 # problem dimension
A <- triDiag(diagonal = 2, upper = -1, lower = -1, nrow = N)
# condition number
# https://en.wikipedia.org/wiki/Condition_number#Matrices
kappa(A)
knitr::opts_chunk$set(echo = TRUE)
library("animation")
Outer <- function(x,y,fun) {
mat <- matrix(NA, length(x), length(y))
for (i in seq_along(x)) {
for (j in seq_along(y)) {mat[i,j] <- fun(x[i],y[j])} }
mat}
printf <- function(...) cat(sprintf(...))
printfln <- function(...) cat(sprintf(...), "\n")
plot(dist ~ speed, cars)
f <- function(ab){
sum = 0
n <- length(cars$dist)
s <- cars$speed
d <- cars$dist
return(1/n * sum((ab[1] + ab[2] * s - d)^2))
}
f_xy <- function(x,y) return(f(c(x,y)))
g <- function(ab){
n <- length(cars$speed)
s <- cars$speed
d <- cars$dist
g_a <- 1/n * sum(2 * (ab[1] + ab[2] * s - d) )
g_b <- 1/n * sum(2 * (ab[1] + ab[2] * s - d) * s)
return(c(g_a,g_b))
}
backtracking_line_search <- function(alpha, c, rho, x_k, p_k, g_k, f) {
alpha_k <- alpha
repeat {
lhs <- f(x_k + alpha_k * p_k)
rhs <- f(x_k) + c * alpha_k * g_k %*% p_k
if (lhs <= rhs) break
alpha_k <- rho * alpha_k
}
return(alpha_k)
}
steepest_descent <- function(f, g, x_k, alpha, c, rho, tol, k_max) {
N <- 30
x <- seq(-20,3,length=N)
y <- seq(1,7,  length=N)
z <- Outer(x , y , f_xy)
lev <- c(300,500,750,1000,2000,4000)
contour(x, y, z, levels = lev)
k <- 0
g_k <- tol + 1 # For at komme i gang
while ((norm(g_k , type="2") > tol) & (k < k_max)) { # Type 2 er for vektorer
g_k <- g(x_k)
p_k <- -g_k
alpha_k <- backtracking_line_search(alpha, c, rho, x_k, p_k, g_k, f)
x_old <- x_k
x_k <- x_k + alpha_k * p_k
k <- k + 1
lines(c(x_old[1],x_k[1]) , c(x_old[2],x_k[2]) , col = "red")
}
printfln("k = %d \t x_k = (%6.3f , %6.3f) \t f_k = %.2f \t g_k = (%8.3f , %8.3f) \t alpha_k = %.5f", k, x_k[1] , x_k[2], f(x_k), g_k[1] , g_k[2], alpha_k)
return(x_k)
}
x_sol <- steepest_descent(f, g, x_k   = c(1,5) ,
alpha = 1      ,
c     = 1e-4   ,
rho   = 0.5    ,
tol   = 1e-4   ,
k_max = 20000)
plot(dist ~ speed , cars)
abline(x_sol , col = "red")
legend(4,115,legend = "m(s) = a + bs" , col = "red" , lty = 1)
f_xy <- function(x,y) return(f(c(x,y)))
f <- function(ab){
sum = 0
n <- length(cars$dist)
s <- cars$speed
d <- cars$dist
return(1/n * sum((ab[1] + ab[2] * s - d)^2))
}
f_xy <- function(x,y) return(f(c(x,y)))
clear
#Library to load images into R.
#You my have to install it first ---> installer.packages("imager)
install.packages("imager")
library("imager")
install.packages("magrittr")
install.packages("imager")
library("imager")
install.packages("imager")
install.packages("imager")
#Load the image
img <- load.image("candy.jpg")
#Library to load images into R.
#You my have to install it first ---> installer.packages("imager)
install.packages("imager")
library("imager")
#Library to load images into R.
#You my have to install it first ---> installer.packages("imager)
install.packages("imager")
library("imager")
#Load the image
img <- load.image("candy.jpg")
library("imager", lib.loc="/Library/Frameworks/R.framework/Versions/3.5/Resources/library")
library("imager")
#Load the image
img <- load.image("candy.jpg")
detach("package:imager", unload=TRUE)
library("imager", lib.loc="/Library/Frameworks/R.framework/Versions/3.5/Resources/library")
#Library to load images into R.
#You my have to install it first ---> installer.packages("imager)
install.packages("imager")
remove.packages("imager")
#Library to load images into R.
#You my have to install it first ---> installer.packages("imager)
install.packages("imager")
library("imager")
rm(list=ls())   #Delete old variables
graphics.off()  #Delete old plots
library("imager")
remove.packages("imager")
install.packages("imager")
library("imager")
install.packages("imager")
install.packages(c("animation", "backports", "class", "codetools", "digest", "evaluate", "foreign", "jsonlite", "knitr", "lattice", "markdown", "MASS", "Matrix", "mgcv", "microbenchmark", "mime", "Rcpp", "rmarkdown", "Rmpfr", "stringi", "stringr", "survival", "tinytex", "xfun"))
library("imager")
install.packages("magrittr")
library("imager")
library("animation")
detach("package:animation", unload=TRUE)
install.packages("imager")
library("imager")
rm(list=ls())
graphics.off()
set.seed(2)
x=matrix(rnorm (50*2), ncol=2)
x[1:25,1]=x[1:25,1]+3
x[1:25,2]=x[1:25,2]-4
num = 1:50
hc.complete =hclust(dist(x), method="complete")
clust = cutree(hc.complete , 2)
par(mfrow = c(1,2))
par(mar=c(2,2,2,2))
plot(x , main="Data", xlab="", ylab="", type='n', xaxt='n',yaxt='n')
text(x[,1],x[,2],col=clust,labels =as.character(num), cex=0.4)
plot(hc.complete ,main="Complete Linkage", xlab="", ylab="",sub="", cex=.4, hang=-1)
data("iris")
kmeans(K=3, N=10)
?kmeans
kmeans(x, K=3, N=10)
kmeans(x,3,10)
load(iris)
?tail
head(iris)
(73.89-72.37)/72.37 *100
(94,49-71,86)/71.86*100
(94.49-71.86)/71.86*100
(91.88-71.86)/71.86*100
(91.31-71.86)/71.86*100
(101.54-71.86)/71.86*100
(73.75-71.86)/71.86*100
residuals.lm(dk1p)
residuals.lm(arima(dk1p))
y <- arima.sim(model=list(ma=0.3, order =c(0,0,1)), n=10000)
y <- arima.sim(model=list(ma=0.3, order =c(0,0,1)), n=10000)
plot(y)
acf(y)
diff(y)
x=diff(y)
acf(x)
vartime = function(x, nmax = round(length(x) / 10)) {
v = rep(NA, nmax);
for (n in 1:nmax) {
y = filter(x, rep(1/n, n), sides = 1);
v[n] = var(y, na.rm = TRUE);
}
plot(log(1:nmax), log(v));
lmv = lm(log(v) ~ log(1:nmax));
abline(lmv);
title(paste(deparse(substitute(x)), "; nmax = ", nmax));
print(summary(lmv));
}
vartime(log(varve))
vartime(residuals(lm(log(varve) ~ time(log(varve)))))
vartime = function(x, nmax = round(length(x) / 10)) {
v = rep(NA, nmax);
for (n in 1:nmax) {
y = filter(x, rep(1/n, n), sides = 1);
v[n] = var(y, na.rm = TRUE);
}
plot(log(1:nmax), log(v));
lmv = lm(log(v) ~ log(1:nmax));
abline(lmv);
title(paste(deparse(substitute(x)), "; nmax = ", nmax));
print(summary(lmv));
}
vartime(log(varve))
vartime(residuals(lm(log(varve) ~ time(log(varve)))))
plot(vartime())
plot(vartime(10))
plot(vartime())
adf?
?adf
clc
cleart
clear
?adf
adf.test?
adf.test
?adf.test
install.packages("EbayesThresh")
library("EbayesThresh", lib.loc="/Library/Frameworks/R.framework/Versions/3.6/Resources/library")
y = c(4,6,6,7,3,5,3,11,10,5)
mean1 = 6
var1 = 10
postmean(y)
postmean(mean1)
postmean(mean1, prior = "gamma")
?postmean
mean = 66*0.099
var = mean^2
var = (66*0.099)^2
y. = sum(y)
alpha = 6
beta = 10
60^2
alpha1 = y. + alpha
beta1 = beta / (1+lenght(y)*beta)
beta1 = beta / (1+length(y)*beta)
?length
beta1 = beta / (1+length(y)*beta
mean = alpha1*beta1
beta1 = beta / (1+length(y)*beta)
mean = alpha1*beta1
var = (alpha1*beta1)^2
y = c(4,6,6,7,3,5,3,11,10,5)
y. = sum(y)
alpha = 6
beta = 10
alpha1 = y. + alpha
beta1 = beta / (1+length(y)*beta)
mean = alpha1*beta1
var = (alpha1*beta1)^2
a = sqrt(6/sqrt(10))
b= 6/1.377
a*b
b= 6/a
a*b
a*b^2
var = alpha1*beta1^2
a*b
a*b^2
b2= 10/a^2
b2
sqrt(b2)
b = sqrt(b2)
a*b
a*b^2
a*b2
a*b^2
b2= 10/a
b = sqrt(b2)
a*b
a*b^2
nthroot(10/6,3)
sqrt(10/6)
sqrt(1.290994)
6/1.136219
---
b2 = sqrt(10/6)
b = sqrt(b2)
---
b2 = sqrt(10/6)
b = sqrt(b2)
b2 = sqrt(10/6)
b = sqrt(b2)
a = 6 / b
a*b
a*b2
a*b^2
6/a
a*b
a*b^2
b = 6/ a
a = 6 / b
a*b
a*b^2
y = c(4,6,6,7,3,5,3,11,10,5)
y. = sum(y)
alpha = 6
beta = 10
alpha1 = y. + alpha
beta1 = beta / (1+length(y)*beta)
mean = alpha1*beta1
var = alpha1*beta1^2
b2 = sqrt(10/6)
b = sqrt(b2)
b = 6/ a
a = 6 / b
b = 6/ a
a*b
a*b^2
b = sqrt(10/3.6)
a = 3.6
a*b
a*b^2
mean = 6
var = 10
beta = sqrt(10/alpha)
y = c(4,6,6,7,3,5,3,11,10,5)
y. = sum(y)
mean = 6
var = 10
alpha = 36/10
beta = sqrt(10/alpha)
alpha1 = y. + alpha
beta1 = beta / (1+length(y)*beta)
mean = alpha1*beta1
mean = 6
var = 10
mean1 = alpha1*beta1
var = alpha1*beta1^2
var = 10
var1 = alpha1*beta1^2
?Gamma
Gamma(alpha)
(0.0943)^-63.6/3.772
f = (beta1)^-alpha1 / 3.772e+86
f
qlower = qgamma(0.05 / 2, alpha1, beta1)
alphaconf = 0.05
qlower = qgamma(alphaconf / 2, alpha1, beta1)
qupper = qgamma((1- alphaconf)/2, alpha1, beta1)
?qgamm
?qgaamma
?qgamma
postinterv = c(qlower,qupper)
postinterv
y = c(4,6,6,7,3,5,3,11,10,5)
y. = sum(y)
mean = 6
var = 10
alpha = 36/10
beta = sqrt(10/alpha)
alpha1 = y. + alpha
beta1 = beta / (1+length(y)*beta)
mean1 = alpha1*beta1
var1 = alpha1*beta1^2
alphaconf = 0.05
qlower = qgamma(alphaconf / 2, alpha1, scale = beta1)
qupper = qgamma((1- alphaconf)/2, alpha1, scale = beta1)
postinterv = c(qlower,qupper)
postinterv
qlower = qgamma(alphaconf / 2, alpha1, scale = 1/beta1)
qupper = qgamma((1- alphaconf)/2, alpha1, scale = 1/beta1)
postinterv = c(qlower,qupper)
postinterv
qlower = qgamma(alphaconf / 2, alpha1, scale = beta1)
qupper = qgamma((1- alphaconf)/2, alpha1, scale = beta1)
postinterv = c(qlower,qupper)
postinterv
qlower = qgamma(alphaconf / 2, alpha1, 1/beta1)
qupper = qgamma((1- alphaconf)/2, alpha1, 1/beta1)
postinterv = c(qlower,qupper)
postinterv
qlower = qgamma(alphaconf / 2, alpha1, scale = beta1)
qupper = qgamma((1- alphaconf)/2, alpha1, scale = beta1)
postinterv = c(qlower,qupper)
postinterv
sqrtvar1 = sqrt(var1)
aaa = mean1 + 2*sqrtvar1
bbb = mean2 - 2*sqrtvar1
bbb = mean1 - 2*sqrtvar1
ccc = c(aaa,bbb)
x <- round(rgamma(100,shape = alpha1,rate = beta1),1)
hist(x)
x <- round(rgamma(100,shape = alpha1,rate = 1/beta1),1)
hist(x)
?rgamma
x <- round(rgamma(length(y),shape = alpha1,rate = 1/beta1),1)
hist(x)
ccc = c(aaa,bbb)
ccc
ccc = c(bbb,aaa)
ccc
alphaconf = 0.05
qlower = qgamma(alphaconf / 2, alpha1, scale = beta1)
qupper = qgamma((1- alphaconf)/2, alpha1, scale = beta1)
postinterv = c(qlower,qupper)
postinterv
?qgamma
qlower = qgamma(alphaconf / 2, alpha1, rate =beta1, scale = 1/rate)
qlower = qgamma(alphaconf / 2, alpha1, rate = beta1, scale = 1/beta1)
qlower = qgamma(alphaconf / 2, alpha1, rate = beta1)
qupper = qgamma((1- alphaconf)/2, alpha1, rate = beta1)
postinterv = c(qlower,qupper)
postinterv
qupper = qgamma((1- alphaconf)/2, alpha1, scale = beta1)
postinterv = c(qlower,qupper)
qlower = qgamma(alphaconf / 2, alpha1, scale = beta1)
qupper = qgamma((1- alphaconf)/2, alpha1, scale = beta1)
postinterv = c(qlower,qupper)
postinterv
beta1^alpha1
alpha1 = y. + alpha
beta1 = beta / (1+length(y)*beta)
mean1 = alpha1*beta1
var1 = alpha1*beta1^2
alphaconf = 0.05
qlower = qgamma(alphaconf / 2, alpha1, scale = beta1)
qupper = qgamma((1- alphaconf)/2, alpha1, scale = beta1)
postinterv = c(qlower,qupper)
postinterv
sqrtvar1 = sqrt(var1)
aaa = mean1 + 2*sqrtvar1
bbb = mean1 - 2*sqrtvar1
ccc = c(bbb,aaa)
ccc
qupper = qgamma(1- alphaconf/2, alpha1, scale = beta1)
postinterv = c(qlower,qupper)
postinterv
y = c(4,6,6,7,3,5,3,11,10,5)
y. = sum(y)
mean = 6
var = 10
alpha = 36/10
beta = sqrt(10/alpha)
alpha1 = y. + alpha
beta1 = beta / (1+length(y)*beta)
mean1 = alpha1*beta1
var1 = alpha1*beta1^2
alphaconf = 0.05
qlower = qgamma(alphaconf / 2, alpha1, scale = beta1)
qupper = qgamma(1- alphaconf/2, alpha1, scale = beta1)
postinterv = c(qlower,qupper)
postinterv
y = c(4,6,6,7,3,5,3,11,10,5)
y. = sum(y)
mean = 6
var = 10
alpha = 36/10
beta = sqrt(10/alpha)
alpha1 = y. + alpha
beta1 = beta / (1+length(y)*beta)
mean1 = alpha1*beta1
var1 = alpha1*beta1^2
alphaconf = 0.05
qlower = qgamma(alphaconf / 2, alpha1, scale = beta1)
qupper = qgamma(1- alphaconf/2, alpha1, scale = beta1)
postinterv = c(qlower,qupper)
postinterv
lower = mean1 - 2 * sqrt(var1)
upper = mean1 + 2* sqrt(var1)
c(9lowerr,upper)
c(lower,upper)
dgamma(x = seq(0,10, len = 100), alpha1, scale = beta1)
plot(dgamma(x = seq(0,10, len = 100), alpha1, scale = beta1))
plot(x, dgamma(x = seq(0,10, len = 100), alpha1, scale = beta1))
x = seq(0,10, len = 100)
plot(x, dgamma(x = seq(0,10, len = 100), alpha1, scale = beta1))
setwd("~/Desktop/MAT_ØK/7. semester pt. 2/Projekt/7_semester_pt_2")
library(forecast)
library(tseries)
T = 100 #Observationer
N = 10000 #Gentagelser
tstat = c()
yt=c()
tstat1 = c()
for(j in 1:N){
y = numeric(T+50)
y[1] = 0
a = 1
for(i in 2:length(y)){
y[i] <- a * y[i - 1] + rnorm(1)
yt = y[51:150]
}
adf = adf.test(yt, k =0)
tstat = print(adf$statistic)
tstat1[j] = tstat
}
adf_dens = density(tstat1)
plot(adf_dens)
plot(adf_dens, y = "percentile")
plot(percentage(adf_dens))
?scale
plot(adf_dens, scale(y)=percent_format())
plot(adf_dens, scale(y, percent_format()))
?percent_format()
percent = percent(adf_dens$y)
?density
density
